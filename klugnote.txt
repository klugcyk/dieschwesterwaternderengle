# 献给我的心上人等待天使的妹妹
# last：230714

# github token 

username:klugcyk
name:liebelili
公钥：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

git init
git add -A
git commit -m "date"
git config --system --unset credential.helper
git remote set-url origin https://liebelili@github.com/klugcyk/dieschewesterwaternderangle.git

多线结构光光源：赫胥尔镭德，镭凯，holoeye

# 投影重构三维重建
1 相移法：https://blog.csdn.net/beyond951/article/details/123361852；
2 基于投影条纹的相移计算物体的真实高度；
3 基于反射率计算物体的本身色彩；
4 相位-高度模型，线性相高模型，逆线性相高模型，多项式相高模型，平行轴相高模型，非平行轴模型；
5 三角立体模型；
6 相位计算：相位主值求取，相位展开（四步相移法，三频外差法）
7 fringe projection profilometry

# 结构光三维重建
1 单线平面标定；
2 多线平面标定；
3 单线三维重建；
4 多线三维重建；
5 

# 同轴结构光三维重建


* 参考博客
三维重建之条纹投影结构光（基于相位差的三维重建模型）
https://blog.csdn.net/beyond951/article/details/123361852

结构光三维重建之光栅图像相位解算
https://blog.csdn.net/weixin_43956164/article/details/105153313


* 参考论文
1 Light plane calibration and accuracy analysis for multi-line structured light vision measurement system（多线结构光标定，scihub）
2 Calibration of fringe projection profilometry: A comparative review
3 A Single Scan Longitudinal Calibration Technique for Fringe Projection Profilometry (scihub)


# cuda

# TensorRT

# cudnn

cmake -G "MinGW Makefiles" -D"CMAKE_MAKE_PROGRAM:PATH=C:/Qt/Qt5.14.2/Tools/mingw730_32/bin/mingw-make.exe" ..

大为数据库网址：https://www.innojoy.com/search/index.html
账号：zscqglpt@sunnyoptical.com
密码：abc098

旋转矩阵相乘，左乘相对于固定坐标，右乘相对于当前坐标

sudo docker run --rm -it universalrobots/ursim_cb3

# 研发代码
31000694基于多点三维模态分析的智能化振动传感器开发
31000169工业机器人3D激光传感器开发

# 结构光相机部件
光源：VCSEL、DOE、WLO、Fliter

# git create

git init 初始化，创建本地仓库
git add . 添加到本地仓库
git commit -m "注释" 添加注释
git remote add origin https://gitee.com/klug/dulcineadeltoboso.git
git pull --rebase origin master 同步仓库内容
git push -u origin master 上传到远程仓库

git ssh 可以不需要账号密码访问repo

# AI图像算法


# 传统图像处理算法

* 空间域
1 图像二值；
2 图像灰度直方图；
3 图像形态学；
4 sobel卷积；
5 canny边缘提取；
6 高斯滤波；
7 均值滤波；
8 图像线性增强；
9 图像对数增强；
10 图像指数增强；
11 图像金字塔；
12 laplance算子；
13 自定义线性滤波，自定义卷积核完成卷积操作；
14 像素重映射 remap()；
15 直方图均衡化；
16 直方图反向投影calcbackproject()；
17 模板匹配（template match）macthTemplate()；
18 轮廓发现findcontours()，drawcontours(;)
19 轮廓周围绘制矩形 approxPolyDP()，可减少多边形轮廓点数，基于RDP实现，boundinRect() 得到轮廓周围最小矩形（最小外接矩形） minAreaRect() 得到旋转矩形；
20 轮廓周围绘制圆和椭圆 minEncloseingCircle() 得到最小外接圆，fitEllipse() 得到最小外接椭圆；
21 图像矩（image Moments），几何矩，中心矩，中心归一化矩，cv：：moments；contourArea()（输入轮廓数据，返回绝对值），arcLength()（输入曲线数据，是否为封闭曲线）；
22 提取图像边缘，计算边缘不封轮廓的矩；
23 凸包计算，graham扫描法，cv::convexHull()；
24 多边形测试，测试给定一个点是否在多边形内部，cv::pointPolygonTest()；
25 图像分割：分割出图像中需要的部分，将图像分为N个集合，监督学习，无监督学习；
26 分水岭的图像分割算法基于浸泡理论实现,cv::watershed()；
27 距离变换：类似图像多变型，根据像素点里边缘最近的距离，设置像素值，cv::distanceTransform()；
28 图像锐化;
29 图像积分cv::intrgral()；


* 频域
1 图像傅里叶变换；
2 图像小波变换；


* 特征
1 sift特征；
2 Harris角点；
3 surf特征点；
4 HOG特征；
5 Flann快速最临近匹配；
6 霍夫直线检测 HoughLines；
7 霍夫圆检测 HoughCircles；
8 Shi-Tomasi角点检测cv::goodFeaturesToTrack()；
9 自定义角点检测器：cv::cornerEigenValsAndVecs(),cv::cornerMinEigenVal()；
10 LBP特征，具有旋转不变性；
11 LBPH特征；
12 FAST角点检测；
13 MinEngen角点检测；
13 Brisk特征点描述；
14 ORB;
15 Haar特征；
16 Flann特征，快速最近邻匹配,FlannBasedMatcher matcher；
17 opencv数据类型KeyPoint，vector<KeyPoint> kp；
17 opencv数据类型DMatch，vector<DMatch> m；


* 图像色彩空间
1 RGB;
2 HSV;
3 HSL;
4 LAB;


# PCL点云处理


# 计算机组成原理

* 真值与机器数
计算机中真实参与计算的是补码
反码：原码到补码的中间过程
原码：符号位+数值位
反码：符号位不变，数值位取反
补码：反码+1
正数的原码，反码，补码一样
计算机只会做加法操作

* 字符编码
1 ascii 字符编码
2 GBK2312 中文编码，2个字节表示一个汉字
3 UTF-8 国际通用字符集，1-4个字节

* 定点数

确定的小数点的位置，不需要点号
表示范围小，运算简单，运算精度低，不是可科学运算

1 定点整数
纯整数，没有小数部分

2 定点小数
小数点在符号位之后，纯小数，没有整数部分

定点数运算
1 利用补码运算
2 不考虑正负
3 做减法转换成加法，将减数利用补码取反，再做加法
4 算数运算：加，减，乘，除
5 逻辑运算：与，或，非，同或（与同一个数同或两次结果不变），左移，右移

* 浮点数
1 小数点位置不固定，需要根据需要浮动，利用科学计数法乘进制的多少次来移动小数点的位置
2 尾数，有效数字，反应数的精度，尽可能多的保留有效数字，提高数的精度
3 基值，进制数
4 阶码，小数点的位置，表示数时，乘以进制的多少次数，多少次为阶码
5 在内存中小数的占位：阶符+阶码+数符+尾数
6 阶符为阶码的正负
7 数符表示为浮点数的正负

# 计算机操作系统

* 操作系统的概念
管理计算机硬件和软件的计算机程序

* 计算机系统构成
1 用户
2 应用程序
3 操作系统
4 硬件

操作系统向用户开放接口，为应用程序也提供接口，完成操作

1 系统软件直接对硬件操作
2 对资源共享调度管理
3 解决并发操作处理中存在的协调问题
4 数据接口复杂，外部接口多样化
5 提供一个让用户与系统交互的操作界面
6 管理和配置内存
7 操作网络与管理文件等基本事务


# 计算机网络

* 计算机网络组成
1 计算机（pad，手机，广义的计算机）
2 传输介质（网线）
3 软件
4 协议

* 工作方式：
1 边缘部分：电脑
2 核心部分：实现计算机网络的路由器

* 功能组成
通信子网：计算机底层通讯
资源子网：计算机内部系统中格模块之间通讯

* 数据通讯：传输信道，数据终端
* 资源共享：数据和应用程序，网络存储和备份，设备

* 分布式处理和负载均衡
* 提高可靠性


# 计算机数据结构

* 孩子表示法(从跟开始表示)

1 双亲表示法找不到对应的子节点，需要对整个树扫描，效率较低
2 顺序存储和链式存储的结合

将每个节点和孩子节点用单链表链接起来，形成一个线性结构，N个节点就会有N个孩子链表
与双亲节点不同存储的是孩子节点的指针
只链接其孩子节点，不链接孙子节点

* 孩子兄弟表示法（二叉树）

链式存储的方式

链表节点中两个链域分别指向该节点的第一个孩子节点和下一个兄弟节点

可以将多叉树转换为二叉树

* 双亲表示法

结合数组存储树结构

三个数组表示树
1 parent（伪指针，指向父节点的索引，对应data中的数据，表示其父节点的位置在index中）
2 data (节点中的数据)
3 index (索引，存储父节点的索引)

树的存储结构
1 顺序存储
2 链式存储

数组对应顺序存储，链表对应链式存储

树结构是逻辑上的结构，逻辑上认为有层次和结构，在内存中没有任何关系

* 森林

森林时m棵互不想交的树的集合
既可存在顺序存储，又可链式存储

* 二叉树

1 节点的度<=2的有序树
2 满二叉树：高为h，节点数为2^h-1,只有最后一层有叶子节点，不存在度为1的节点
3 只有最后两层有叶子节点
4 最多有一个度为1的节点
5 非空二叉树中，叶子节点比二分支节点多一个，n0,n1,n2，分别表示度为0，1，2的节点数量，n0=n2+1

* 二叉树的存储结构

顺序存储
1 用数组存储，0处空缺，以便与下标对标完全二叉树，按序号对应索引位置，
i的左孩子，2i
i的右孩子，2i+1
i的父节点，i/2
i的层次，log2（i+1）

* 二叉排序树

任意节点与其左右节点的关键字大小关系满足左<中<右

* 平衡二叉树

任意节点的左右树深度差不超过1

* 完全二叉树

当且仅当树中每个节点序号斗鱼同等高度的满二叉树序号对应，不需要铺满，只需要对应

链式存储
用链表存储，链表节点对应树的节点，其中包含一个数据域和若干个指针域（left，right）
1 左右指针分别表示左右节点，节点不存在对应节点为空
2 不适合从子节点找到父节点，通过增加指向父节点的指针，构成三叉链表存储结构
3 空链域，没有子节点的节点，构成空链域，度为2的节点没有空链域
4 特点：增删快，存取慢

* 访问二叉树
本质访问数的节点，访问树的所有节点，二叉树的遍历
1 先序遍历preorder
根左右 NLR
根在最前面，从根开始向下搜索
先遍历根节点，再往左节点走，先访问完左子树，再访问右节点，访问到叶节点，开始访问右节点，再退回上一层（循环）,左子树为叶节点是停止访问
一开始从第一个根节点，后面用其他层的节点作为根节点（度不为0）

2 中序遍历inorder
左根右 LNR
根在最前面，从根开始向下搜索
先访问左节点，再访问根节点，再访问右节点
先看是否存在左子树，访问完左子树在访问根节点，最后访问右子树
先找根节点，看有没有左子树，有左子树，则先看左子树，没有左子树再访问

3 后序遍历postorder
左右根 LRN
从根节点开始，先访问左右再访问根，直到读到叶节点，访问完左右节点再访问对应的根节点
只有一个的根节点放在最后访问

4 层次遍历levelorder
按层遍历，临时存储访问的节点
每一层需要一个容器缓存访问过的节点
访问一个节点，就把节点的子节点放进容器中，进容器的顺序和出容器的顺序一样，先进先出
利用队列（容器）,完成树的访问
直到队列为空时，树访问完成

*** 从线性序列恢复到二叉树，恢复的结果不是唯一的 ***

* 线索二叉树，链式存储
提高遍历速度，利用空链域存储节点的前驱和后继
两个无直接链接的节点相邻读取
1 每个节点都增设两个标志域LTag（左指针）和RTag（右指针）
2 LTag为0是指向该结点的左孩子，为1时指向该结点的前驱
3 RTag为0是指向该结点的右孩子，为1时指向该结点的后继
4 借用空的子节点（空链域）指向想访问的地址，分为左右
5 L指向前驱，R指向后继
6 LTag或RTag值为0，则表示指向左右子节点
7 在遍历完左子树后，可通过叶子节点上的LTag或RTag指向右子树的某个节点访问，不返回根节点，直接访问提高速度
8 度为2的节点不需要设置Tag，LTag和RTag直接为0
9 前序遍历：按根左右，到叶节点右，根据L和R指针直接访问右节点（右节点存在），不返回父节点，
10 若右节点不存在，R指针指向上一层的另一个父节点


中序遍历
左根右的顺序，从最左边的叶节点开始
第一个访问的节点，没有前驱节点，L指针指向null，R指针指向父节点，
最后一个访问的节点没有指向，R指针指向null
到父节点的右节点的R指针，指向


后序遍历
构造叶子节点和度为1的节点
先左子树，在右子树，最后根


二叉树的应用场景

1 二叉查找树BST
排序，搜索
左子树非空，所有左子树节点值小于根
右子树非空，所有右子树节点值大于根
每个节点符合左边小右边大
利用中序遍历得到一个递增序列
查找：每次查找某个节点都与当前节点比较，从根节点开始查找，如果比节点大往右侧查找，如果比节点小往左侧查找
插入：先确定插入位置，从根节点开始，比根节点小往左走，否则往右走（基于查找）
删除：从根节点开始，比较大小，确定去左子树或右子树查找节点，把相对应的指针断开，删除度为2的节点，需要填上新的（基于查找）
删除叶节点：直接断开
删除度为1的节点：子树上升，与删除的节点的父节点直接相连
*删除度为2的节点：把前驱节点或后驱节点直接放在删除节点的位置

2 平衡二叉树AVL
任意节点的左右子树的高度差不超过1（高度差（平衡因子）=左子树-右子树）
插入和删除时，有可能影响某些节点的平衡因子
最小不平衡树：调整最小不平衡树（旋转），完成符合规则，再向上查找最小不平衡二叉树
右单LL旋转：最小不平衡树的根节点的左节点代替当前节点，当前节点作为旋转后的右节点，
左单RR旋转：。。。
先左后右旋转LR：最小不平衡树先向左旋转，（需要满足树的构造原则，重新组合最小不平衡树），原根节点作为左节点，右侧的叶节点放在左侧的树上，再向右旋转，最小不平衡树的上一个节点下移作为右节点，旋转后最小不平衡树的根节点代替
先右后左旋转RL：。。。

3 哈夫曼树Huffman tree
带权路径最短的树
权：对节点属性的数值描述
节点带权路径长度：节点到根的路径长度与节点的权的乘积
树的带权路径长度：树中所有叶子节点带权路径长度之和WFL
哈夫曼树：含有n个带权叶子节点的二叉树中，带权路径长度WFL最小的二叉树称为最优二叉树，哈夫曼树
哈夫曼树不唯一，但是WPL必然是唯一的
哈夫曼树构造：
1 将所有节点看作只有一个节点的二叉树，则所有树构成森林
2 创建新节点，选择两个权值最小的树作为其左右树，新节点权值为二者之和
3 将构成的新树放回原森林中，重复上述步骤知道森林中只剩一颗树为止
构造出来的节点都位于叶子节点上
整个合并过程中不存在度为1的节点
哈夫曼编码：编码问题
任意两个字符的编码不能为对方前缀
从根节点到叶节点的路径是唯一的
可以用一条路径表示一个字符进行编码
字符出现的次数越多，在全文中的权值越大，则使用离根节点近的节点表示这些字符，节省全文长度


# C++

* 结构体
自定义的数据类型，允许用户存储不同的数据类型
struct 成员名
{ 
成员变量
}a；//顺便创建结构体变量a

结构体创建时，可以嵌套

* class

public，可在类外调用

protected，可以被派生对象在类内调用，无法再类外调用

private，可以在当前类中调用，无法在其他地方调用

* 数组

一维数组

多维数组
1 多维数组在内存中是连续的
2 定义多维数组的行列后，可不加分隔定义数组，会自动识别分行
3 定义多维数组时，可省略行数，不可省略列数

可同数组名查看数组长度（占用空间大小），查看数组的首地址

* 容器

1 vector

2 deque

3 set

4 list

* 指针

32位操作系统下所有指针占4个字节，64位操作系统下占8个字节

空指针：指针指向的地址为0的区域

野指针：指针指向的地址为未知的


* 智能指针

* 线程锁：std::mutex m
std::lock_guard<std::mutex> mtx(m);

std::unique_lock<std::mutex> mtx(m);

* 线程

* 进程

* 不常用不建议使用关键字
1 goto（不建议使用）
2

* conse修饰的变量
1 不允许修改变量的值，对变量做写保护；
2 指针用const修饰时，可在前或在后，指针指向不可修改，指针指向变量的值不可修改；

* explicit

* 内存分区模型
1 代码区：存放函数体的二进制代码，由操作系统进行管理；
2 全局区：存放全局变量和静态变量，局部变量等；
3 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等；
4 堆区：由程序员分配和释放，若程
序员不释放，在程序结束后，由操作系统回收；

* 代码区
存放CPU执行的机器指令，程序运行前存在
代码区是共享的，共享目的在于过于频繁被执行程序，只需要在内存中有一份代码即可
代码区是只读的，防止程序意外修改指令


* 全局区
程序运行前存在，
全局变量，静态变量，常量存放在此，由操作系统管理释放
全局变量：与局部变量在内存的分区中不同
静态变量：在普通变量前加static，静态变量与全局变量在内存的分区中在同一段
全局常量：与全局变量在内存的分区中在同一段
局部常量：const修饰的局部变量，与局部变量在内存中分区在同一段


* 栈区
有编译器管理分配和释放，不要返回局部变量的地址，栈区的数据在程序执行完后释放，
第一次可以读取到数据是编译器做了保留，第二次无法读取正确的数值
1 函数参数，函数形参
2 局部变量


* 堆区
在程序运行后，程序员管理释放，如果程序运行期间不释放，在程序结束后由操作系统释放
new关键词，在堆区开辟数据
int * p=new int (10); //可在函数中使用返回
堆区数据释放：


# cuda
